# 计算物理第四次作业

## 第一题：计算矩阵本征值

### 解答

#### 1. QR 算法

QR 算法通过反复进行 QR 分解 $A_k = Q_k R_k$ 并更新 $A_{k+1} = R_k Q_k$ 来使矩阵收敛到上三角矩阵，对于对称矩阵为对角矩阵。

核心代码如下：
```python
def qr_algorithm(A, max_iter=50, tol=1e-6):
    n = A.shape[0]
    Ak = A.copy()
    print(f"初始矩阵:\n{Ak}")
    
    for k in range(1, max_iter + 1):
        Q, R = np.linalg.qr(Ak)
        Ak = R @ Q
        
        if k % 5 == 0:
            print(f"\n第 {k} 次迭代:")
            print(Ak)
        
        # 检查收敛性，判断非对角元素的绝对值和是否小于容差
        off_diagonal = np.sum(np.abs(Ak)) - np.sum(np.abs(np.diag(Ak)))
        if off_diagonal < tol:
            print(f"\n{k} 次迭代后收敛。")
            break
            
    print("\nQR算法特征值:", np.diag(Ak))
    return np.diag(Ak)
```

#### 2. Jacobi 算法
Jacobi 算法通过一系列相似变换（即旋转）将对称矩阵对角化，每次选择模最大的非对角元素进行消除。

核心代码如下：
```python
def jacobi_algorithm(A, max_iter=1000, tol=1e-8):
    n = A.shape[0]
    Ak = A.copy()
    
    for k in range(max_iter):
        # 找到最大的非对角元素
        max_val = 0.0
        p, q = -1, -1
        for i in range(n):
            for j in range(i + 1, n):
                if abs(Ak[i, j]) > max_val:
                    max_val = abs(Ak[i, j])
                    p, q = i, j
        
        if max_val < tol:
            print(f"\n{k}次迭代后收敛。")
            break
            
        # 计算旋转参数
        if Ak[p, q] == 0:
            c = 1.0
            s = 0.0
        else:
            eta = (Ak[q, q] - Ak[p, p]) / (2 * Ak[p, q])
            if eta >= 0:
                t = 1.0 / (eta + np.sqrt(1 + eta**2))
            else:
                t = -1.0 / (-eta + np.sqrt(1 + eta**2))
            
            c = 1.0 / np.sqrt(1 + t**2)
            s = t * c
        
        # 构造Jacobi旋转矩阵
        J = np.eye(n)
        J[p, p] = c
        J[q, q] = c
        J[p, q] = s
        J[q, p] = -s
        
        Ak = J.T @ Ak @ J
        
    print("\nJacobi算法特征值:", np.diag(Ak))
    return np.diag(Ak)
```

#### 3. Sturm 序列 + 对分法
利用 Sturm 序列的性质计算给定区间内本征值的个数，结合对分法精确定位本征值。

核心代码如下：
```python
def sturm_sequence_count(d, e, lam):
    """
    计算Sturm序列在λ处的符号变化次数
    :param d: 矩阵的对角元素
    :param e: 矩阵的副对角元素
    """
    n = len(d)
    
    # 初始化Sturm序列，P0(λ) = 1.0
    seq = [1.0]

    # 计算P1(λ) = d[0] - λ
    val = d[0] - lam

    # 用一个非常小的数替换零值，方便符号变化的计算
    if val == 0:
        val = 1e-15
    seq.append(val)
    
    # 递推计算P_k(λ)： P_k(λ) = (d[k-1] - λ) * P_{k-1}(λ) - (e[k-2])^2 * P_{k-2}(λ)
    for k in range(2, n + 1):
        val = (d[k-1] - lam) * seq[-1] - (e[k-2]**2) * seq[-2]
        # 替换零值
        if val == 0:
            val = 1e-15
        seq.append(val)
        
    # 计算符号变化次数
    changes = 0
    for i in range(len(seq) - 1):
        if (seq[i] > 0 and seq[i+1] < 0) or (seq[i] < 0 and seq[i+1] > 0):
            changes += 1
    return changes

def sturm_bisection(A, tol=1e-6):
    # 提取对角线和副对角线元素
    d = np.diag(A)
    e = np.diag(A, k=1) 
    n = len(d)
    
    # 利用Gerschgorin圆盘定理计算特征值的初始搜索区间
    max_val = -np.inf
    min_val = np.inf
    for i in range(n):
        row_sum = np.sum(np.abs(A[i, :])) - abs(A[i, i])
        if (row_sum + A[i, i]) > max_val:
            max_val = row_sum + A[i, i]
        if (A[i, i] - row_sum) < min_val:
            min_val = A[i, i] - row_sum
    
    # 避免边界问题，稍微扩大区间
    low = min_val - 1.0
    high = max_val + 1.0
    
    print(f"\n搜索区间: [{low}, {high}]")
    
    found_evals = []
    # 求解第1到第n个特征值（对应k=1到n）
    for k in range(1, n + 1):
        a, b = low, high
        
        for _ in range(100): # 最多迭代100次
            mid = (a + b) / 2
            count = sturm_sequence_count(d, e, mid)
            if count < k:
                # 符号变化次数小于k，说明第k个特征值在mid右侧，更新左边界
                a = mid
            else:
                # 符号变化次数≥k，说明第k个特征值在mid左侧或等于mid，更新右边界
                b = mid
            
            if abs(b - a) < tol:
                break
        
        found_evals.append((a + b) / 2)
        
    print("\nSturm序列+二分法特征值:", np.array(found_evals))
    return np.array(found_evals)
```

### 结果
三种方法计算得到的本征值高度一致：
- **QR 算法**: `[4.74528124, 3.17728292, 1.82271708, 0.25471876]`

- **Jacobi 算法**: `[0.25471876, 3.17728292, 1.82271708, 4.74528124]`

- **Sturm 序列**: `[0.25471872, 1.82271689, 3.17728311, 4.74528128]`

QR算法迭代过程中的矩阵为：

```
第 5 次迭代:
[[ 4.29276628e+00 -7.21313977e-01  7.88275051e-16 -4.68886168e-16]
 [-7.21313977e-01  3.55611356e+00 -3.34967464e-01 -6.93232054e-16]
 [ 0.00000000e+00 -3.34967464e-01  1.89640130e+00  3.99652715e-04]
 [ 0.00000000e+00  0.00000000e+00  3.99652715e-04  2.54718859e-01]]

第 10 次迭代:
[[ 4.73418406e+00 -1.31448547e-01  9.37679537e-16  5.76851629e-17]
 [-1.31448547e-01  3.18812610e+00 -1.85822775e-02  9.98455355e-16]
 [ 0.00000000e+00 -1.85822775e-02  1.82297108e+00 -2.07643140e-08]
 [ 0.00000000e+00  0.00000000e+00 -2.07643133e-08  2.54718760e-01]]

第 15 次迭代:
[[ 4.74507887e+00 -1.78120256e-02  9.31427664e-16  1.54263660e-17]
 [-1.78120256e-02  3.17748431e+00 -1.15075434e-03 -1.00900975e-15]
 [ 0.00000000e+00 -1.15075434e-03  1.82271806e+00  1.10728216e-12]
 [ 0.00000000e+00  0.00000000e+00  1.10658664e-12  2.54718760e-01]]

第 20 次迭代:
[[ 4.74527757e+00 -2.39738535e-03  9.29669406e-16 -2.53480280e-17]
 [-2.39738535e-03  3.17728658e+00 -7.14944440e-05  1.00936313e-15]
 [ 0.00000000e+00 -7.14944440e-05  1.82271708e+00 -7.53694435e-16]
 [ 0.00000000e+00  0.00000000e+00 -5.89784840e-17  2.54718760e-01]]

第 25 次迭代:
[[ 4.74528117e+00 -3.22632786e-04  9.29390562e-16  2.66836011e-17]
 [-3.22632786e-04  3.17728299e+00 -4.44210350e-06 -1.00936309e-15]
 [ 0.00000000e+00 -4.44210350e-06  1.82271708e+00  6.94669130e-16]
 [ 0.00000000e+00  0.00000000e+00  3.14341662e-21  2.54718760e-01]]

第 30 次迭代:
[[ 4.74528124e+00 -4.34188356e-05  9.29350735e-16 -2.68633384e-17]
 [-4.34188356e-05  3.17728292e+00 -2.75997749e-07  1.00936046e-15]
 [ 0.00000000e+00 -2.75997750e-07  1.82271708e+00 -6.94662882e-16]
 [ 0.00000000e+00  0.00000000e+00 -1.67536827e-25  2.54718760e-01]]

第 35 次迭代:
[[ 4.74528124e+00 -5.84316066e-06  9.29345238e-16  2.68875268e-17]
 [-5.84316066e-06  3.17728292e+00 -1.71483529e-08 -1.00935995e-15]
 [ 0.00000000e+00 -1.71483531e-08  1.82271708e+00  6.94662689e-16]
 [ 0.00000000e+00  0.00000000e+00  8.92932493e-30  2.54718760e-01]]

第 40 次迭代:
[[ 4.74528124e+00 -7.86352881e-07  9.29344490e-16 -2.68907820e-17]
 [-7.86352881e-07  3.17728292e+00 -1.06546503e-09  1.00935987e-15]
 [ 0.00000000e+00 -1.06546526e-09  1.82271708e+00 -6.94662677e-16]
 [ 0.00000000e+00  0.00000000e+00 -4.75912342e-34  2.54718760e-01]]
```

---

## 第二题：幂次法求矩阵最大模本征值

### 解答

#### 1. 矩阵构建
根据周期性边界条件，矩阵 $A$ 的形式为：
```
矩阵 A:
[[ 2. -1.  0.  0.  0.  0.  0.  0.  0. -1.]
 [-1.  2. -1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0. -1.  2. -1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0. -1.  2. -1.  0.  0.  0.  0.  0.]
 [ 0.  0.  0. -1.  2. -1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0. -1.  2. -1.  0.  0.  0.]
 [ 0.  0.  0.  0.  0. -1.  2. -1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0. -1.  2. -1.  0.]
 [ 0.  0.  0.  0.  0.  0.  0. -1.  2. -1.]
 [-1.  0.  0.  0.  0.  0.  0.  0. -1.  2.]]
```

#### 2. 幂次法实现

迭代公式：$z^{(k)} = A q^{(k-1)}$, $q^{(k)} = z^{(k)} / \|z^{(k)}\|$。

```python
def power_method(A, max_iter=2000, tol=1e-10):
    # ...
    for k in range(1, max_iter + 1):
        z = A @ q
        norm_z = np.linalg.norm(z)
        q_next = z / norm_z
        lambda_next = np.vdot(q_next, A @ q_next).real 
        # ...
```

### 结果
对于 $N=10$ 的情形：
- **最大本征值 ($\omega_{\text{max}}^2$)**: `4.00000000`
- **理论值**: $4 \sin^2(N\pi / 2N) = 4$。
- **本征矢**: 对应于相邻原子反向振动的模式。

---

## 第三题：孤立子数值解

### 题目描述
求解 KdV 方程 $u_t + u u_x + \delta^2 u_{xxx} = 0$，展示孤立子现象。

### 解答

采用 **Zabusky-Kruskal 格式**（Leapfrog 时间步进 + 中心差分空间离散）：
$$
u_j^{n+1} = u_j^{n-1} - 2\Delta t \left[ \frac{u_{j+1}^n + u_j^n + u_{j-1}^n}{3} \frac{u_{j+1}^n - u_{j-1}^n}{2\Delta x} + \delta^2 \frac{u_{j+2}^n - 2u_{j+1}^n + 2u_{j-1}^n - u_{j-2}^n}{2(\Delta x)^3} \right]
$$

核心代码：
```python
def compute_rhs(u):
    u_jp1 = np.roll(u, -1)
    u_jm1 = np.roll(u, 1)
    u_jp2 = np.roll(u, -2)
    u_jm2 = np.roll(u, 2)
    
    nonlinear = (u_jp1 + u + u_jm1) / 3.0 * (u_jp1 - u_jm1) / (2 * dx)
    dispersion = delta_sq * (u_jp2 - 2*u_jp1 + 2*u_jm1 - u_jm2) / (2 * dx**3)
    
    return -(nonlinear + dispersion)
```

### 结果
初始的余弦波分裂成一列孤立子，振幅大的速度快，振幅小的速度慢。

![KdV Solitons](./assets/kdv_solitons.gif)

---

## 第四题：二维波动方程

### 题目描述
求解二维波动方程，对比解析解与数值解，并分析稳定性。

### 解答

#### (a) 解析解
分离变量法得到：
$$ u(x,y,t) = \sin(\pi x)\sin(2\pi y)\cos(\sqrt{5}\pi t) $$

#### (b) 数值解
使用显式差分格式：
```python
# u^{n+1} = 2u^n - u^{n-1} + rx^2 * u_xx + ry^2 * u_yy
u_np1[1:-1, 1:-1] = 2*u_n[1:-1, 1:-1] - u_nm1[1:-1, 1:-1] + \
                    rx2 * u_n_xx + ry2 * u_n_yy
```

#### (c) 稳定性分析
稳定性条件：$\Delta t \leq \frac{1}{\sqrt{\lambda}} \left( \frac{1}{\Delta x^2} + \frac{1}{\Delta y^2} \right)^{-1/2}$。
- 当 $\lambda=2.0$ (满足 CFL) 时，模拟稳定。
- 当 $\lambda=0.8$ (不满足 CFL) 时，模拟发散。

### 结果

**数值解与解析解对比 ($t=0, 1, 2$)**:
![Comparison](./assets/wave_comparison.png)

**动画展示**:
![Wave Animation](./assets/wave_2d.gif)

---

## 第五题：随机数产生器

### 题目描述
验证随机数分布性质，并实现 16807 产生器。

### 解答

#### (a) 分布检验
统计落入 $[0.6, 0.7]$ 区间的比例，结果符合正态分布。

![Distribution](./assets/random_dist_a.png)

#### (b) $\chi^2$ 检验
计算 $\chi^2 = \sum \frac{(O_i - E_i)^2}{E_i}$，结果符合自由度为 9 的 $\chi^2$ 分布。

![Chi-Square](./assets/random_chi2_b.png)

#### (c) 16807 产生器
实现线性同余发生器：
```python
class LCG16807:
    def __init__(self, seed=1):
        self.state = seed
        self.a = 16807
        self.m = 2147483647
        
    def next(self):
        self.state = (self.a * self.state) % self.m
        return self.state
```
验证结果：$x(10000) = 1043618065$，验证成功。
